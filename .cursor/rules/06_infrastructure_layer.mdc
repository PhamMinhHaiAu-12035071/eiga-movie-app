---
description: 
globs: 
alwaysApply: false
---
# Infrastructure Layer Guidelines

## Directory Structure

```
lib/
  └── features/
      └── feature_name/
          └── infrastructure/
              ├── dtos/                       # Data Transfer Objects
              │   └── feature_dto.dart
              ├── constants/                  # Feature-specific constants (e.g., API endpoints)
              │   └── feature_constants.dart
              └── feature_repository_impl.dart # Implementation of the domain repository interface
```

## Infrastructure Layer Conventions

### DTO Structure

1.  DTOs must:
    *   Be immutable.
    *   Use the `@freezed` annotation.
    *   Include `fromJson` factory constructor for parsing API responses.
    *   Include `toJson` method (often generated by `freezed` with `json_serializable`) if sending data to an API.
    *   Include a `toDomain()` method to convert the DTO to its corresponding domain model (`FeatureModel`).

2.  DTO Properties:
    *   Accurately reflect the structure of the external data source (e.g., API response).
    *   Use `@JsonKey` annotation to map JSON keys (like `snake_case`) to Dart `camelCase` fields.
    *   Use appropriate, specific types (avoid `dynamic`).
    *   Handle potentially null values from the source safely (e.g., using nullable types `String?` and providing defaults in `toDomain()` if necessary).
    *   Include dartdoc comments clarifying the source field if the mapping isn't obvious.

### Constants Structure

1.  Constants file (`feature_constants.dart`) should contain:
    *   Specific API endpoint paths related to the feature.
    *   Magic strings or keys used in API requests/responses for this feature.
    *   Group related constants logically (e.g., using a class with `static const`).
    *   **Note:** Base URLs and global API keys should ideally be managed via `envied` and accessed through a core `EnvConfigRepository` (see `README.md`). Feature constants focus on *feature-specific* parts.

### Repository Implementation Structure

1.  Repository Implementations must:
    *   Implement the corresponding domain layer interface (e.g., `implements FeatureRepository`).
    *   Be annotated with `@LazySingleton(as: FeatureRepository)` or `@Injectable(as: FeatureRepository)` for dependency injection.
    *   Inject necessary dependencies via the constructor (e.g., `Dio` client, `SharedPreferences` instance, other repositories).
    *   Handle all potential errors from the data source (network errors, parsing errors, API-specific errors).
    *   Map data source errors to the domain-specific errors defined in the domain layer (e.g., `FeatureError`).
    *   Convert DTOs received from the data source into domain models before returning them.
    *   Use the `Result` type (`Success` or `Failure`) consistently, matching the interface signature.
    *   Use constants for endpoint paths and keys.

2.  Repository Methods:
    *   Contain logic for fetching/sending data to/from external sources (API, local DB, etc.).
    *   Include error handling logic (`try-catch` blocks) for external calls.
    *   Perform DTO-to-Domain model conversion.
    *   Return `Future<Result<DomainModel, DomainError>>`.

## Naming Conventions

### Files

1.  DTO files:
    *   Use `_dto.dart` suffix (e.g., `feature_dto.dart`).
    *   Use `snake_case`.
    *   Should generally correspond to a domain model or a specific API resource.

2.  Repository Implementation files:
    *   Use `_repository_impl.dart` suffix (e.g., `feature_repository_impl.dart`).
    *   Use `snake_case`.

3.  Constants files:
    *   Use `_constants.dart` suffix (e.g., `feature_constants.dart`).
    *   Use `snake_case`.

### Classes

1.  DTO classes:
    *   Use `PascalCase`.
    *   End with `Dto` (e.g., `FeatureDto`).
    *   Match their file names (without suffix).

2.  Repository Implementation classes:
    *   Use `PascalCase`.
    *   End with `RepositoryImpl` (e.g., `FeatureRepositoryImpl`).
    *   Implement the corresponding `FeatureRepository` interface (without 'I' prefix).

3.  Constants classes (if used):
    *   Use `PascalCase` (e.g., `FeatureConstants`).

## Code Organization

1.  DTOs:
    *   One main DTO per file usually.
    *   Place in the `infrastructure/dtos/` folder.
    *   Include necessary `fromJson`/`toJson`/`toDomain` logic.

2.  Repository Implementations:
    *   One repository implementation per file.
    *   Inject dependencies via constructor.
    *   Handle errors and data conversion.
    *   Include necessary imports for domain models, DTOs, DI, error types, and data sources.

3.  Constants:
    *   Group feature-specific constants in the `infrastructure/constants/` folder.

## Best Practices

1.  DTOs:
    *   Keep DTOs focused solely on data transfer; avoid business logic.
    *   Ensure robust `fromJson` handling (e.g., using `@Default` in `freezed` or null checks).
    *   Make `toDomain()` the bridge to the clean domain layer.

2.  Repository Implementations:
    *   Catch specific exceptions from the data source client (e.g., `DioException`).
    *   Map exceptions to meaningful domain errors.
    *   Keep repository methods focused on orchestrating data retrieval/storage and conversion.
    *   Use a centralized `ApiClient` (like `Dio`) instance provided via DI.
    *   Leverage `envied` for base URLs, API keys accessed via `EnvConfigRepository`.

## Testing Guidelines

1.  Directory Structure:
    ```
    test/
      └── features/
          └── feature_name/
              └── infrastructure/
                  ├── dtos/
                  │   └── feature_dto_test.dart
                  └── feature_repository_impl_test.dart
    ```

2.  DTO Testing:
    *   Test `fromJson` with valid and potentially invalid/incomplete JSON.
    *   Test `toJson` if applicable.
    *   Test `toDomain` conversion logic.

3.  Repository Implementation Testing:
    *   Use `mocktail` to mock ALL dependencies (e.g., `Dio`, `SharedPreferences`).
    *   Test success scenarios: verify correct data source calls, DTO parsing, `toDomain` conversion, and `Success` result.
    *   Test failure scenarios: mock data source exceptions (network errors, 404s, etc.), verify correct error mapping to domain errors, and `Failure` result.
    *   Verify that the correct endpoints/keys are used in calls.

## Code Example

```dart
// infrastructure/dtos/feature_dto.dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:app/features/feature_name/domain/models/feature_model.dart'; // Adjust path

part 'feature_dto.freezed.dart';
part 'feature_dto.g.dart';

@freezed
class FeatureDto with _$FeatureDto {
  const FeatureDto._(); // Private constructor for adding methods

  const factory FeatureDto({
    required String id,
    @Default('') String name,
    @JsonKey(name: 'is_active', defaultValue: false) bool isActive,
  }) = _FeatureDto;

  factory FeatureDto.fromJson(Map<String, dynamic> json) =>
      _$FeatureDtoFromJson(json);

  FeatureModel toDomain() => FeatureModel(
        id: id,
        name: name,
        isActive: isActive,
      );
}

// infrastructure/constants/feature_constants.dart
abstract class FeatureConstants {
  static const String featureEndpoint = '/features'; // Example endpoint path
  static String featureByIdEndpoint(String id) => '/features/$id';
}

// infrastructure/feature_repository_impl.dart
import 'package:app/features/env/env_config_repository.dart'; // Access env vars
import 'package:app/features/feature_name/domain/feature_repository.dart'; // No 'i_' prefix
import 'package:app/features/feature_name/domain/models/feature_model.dart';
import 'package:app/features/feature_name/infrastructure/dtos/feature_dto.dart';
import 'package:app/features/feature_name/infrastructure/constants/feature_constants.dart';
import 'package:dio/dio.dart';
import 'package:injectable/injectable.dart';
import 'package:multiple_result/multiple_result.dart';

@LazySingleton(as: FeatureRepository)
class FeatureRepositoryImpl implements FeatureRepository {
  final Dio _dio;
  final EnvConfigRepository _envConfig; // Inject env config

  FeatureRepositoryImpl(this._dio, this._envConfig);

  @override
  Future<Result<FeatureModel, FeatureError>> getFeature(String id) async {
    try {
      final response = await _dio.get(
        // Construct full URL using base from env config
        '${_envConfig.apiUrl}${FeatureConstants.featureByIdEndpoint(id)}',
      );

      if (response.statusCode == 200 && response.data != null) {
        final dto = FeatureDto.fromJson(response.data as Map<String, dynamic>);
        return Success(dto.toDomain());
      } else {
        // Handle non-200 success codes if necessary
        return const Failure(FeatureError.unknown);
      }
    } on DioException catch (e) {
      // Map Dio errors to domain errors
      if (e.response?.statusCode == 404) {
        return const Failure(FeatureError.notFound);
      }
      // Add more specific error mapping (network, timeout, etc.)
      return const Failure(FeatureError.networkError);
    } catch (e) {
      // Catch any other unexpected errors (e.g., parsing)
      return const Failure(FeatureError.unknown);
    }
  }

  @override
  Future<Result<FeatureModel, FeatureError>> createFeature(
      FeatureModel feature) async {
    try {
      // Convert domain model to DTO for sending
      // final featureDto = FeatureDto.fromDomain(feature); // If needed

      final response = await _dio.post(
        '${_envConfig.apiUrl}${FeatureConstants.featureEndpoint}',
        data: { /* Convert feature model to JSON map */ },
      );

      if (response.statusCode == 201 && response.data != null) {
        final dto = FeatureDto.fromJson(response.data as Map<String, dynamic>);
        return Success(dto.toDomain());
      } else {
        return const Failure(FeatureError.unknown);
      }
    } on DioException catch (e) {
      if (e.response?.statusCode == 400) {
        // Example: Map 400 Bad Request to validation error
        return const Failure(FeatureError.validation);
      }
      return const Failure(FeatureError.networkError);
    } catch (e) {
      return const Failure(FeatureError.unknown);
    }
  }
} 